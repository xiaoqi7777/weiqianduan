<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 如果应用 加载 刚开始加载A 应用 window.a B应用 window.a
    // 单应用切换 沙箱 创建一个干净的环境给这个字应用使用,当切换时 可以选择丢弃属性和恢复
    
    // js 沙箱 proxy
    // 快照沙箱 1年前拍一张 在拍一张 (将区别保存起来)
    // class SnapshotSandBOX{
    //   constructor(){
    //     this.proxy = window;// window属性
    //     this.modifyProsMap = {}; // 记录在window上的修改
    //     this.active();
    //   }
    //   active(){
    //     this.windowSnapshot = {};//拍照
    //     for(const prop in window){
    //       if(window.hasOwnProperty(prop)){
    //         this.windowSnapshot[prop] = window[prop];
    //       }
    //     }
    //     Object.keys(this.modifyProsMap).forEach(p=>{
    //       window[p] = this.modifyProsMap[p]
    //     })
    //   }
    //   inactive(){
    //     for(const prop in window){
    //       if(window.hasOwnProperty(prop)){
    //         if(window[prop] !== this.windowSnapshot[prop]){
    //           this.modifyProsMap[prop] = window[prop];
    //           window[prop] = this.windowSnapshot[prop]
    //         }
    //       } 
    //     }
    //   }
    // }
    // let sandbox = new SnapshotSandBOX();

    // // 沙箱:应用的运行 从开始到街上,切换后不会影响全局
    // ((window)=>{
    //   window.a = 1
    //   window.b = 2
    //   console.log(window.a,window.b)
    //   sandbox.inactive();
    //   console.log(window.a,window.b)
    //   sandbox.active()
    //   console.log(window.a,window.b)
    // })(sandbox.proxy)// sandbox.proxy 就是window

    // 如果是多个子应用就不能使用这个方法 es6的proxy

    // 代理沙箱阔以实现应用沙箱,把不同的应用用不同的代理来处理
      
    // class ProxySandbox{
    //   constructor (){
    //     const rawWindow = window
    //     const fakeWindow = {}
    //     const proxy = new Proxy(fakeWindow,{
    //       set(target,p,value){
    //         console.log('===>',target,p,value)
    //         target[p] = value;
    //         return true
    //       },
    //       get(target,p){
    //         return target[p] || rawWindow[p]
    //       }
    //     })
    //     this.proxy = proxy
    //   }
    // }
    // let sandbox1 = new ProxySandbox();
    // let sandbox2 = new ProxySandbox();
    // window.a = 1;
    // ((window)=>{
    //   window.a = 'hello';
    //   console.log(window.a)
    // })(sandbox1.proxy);

    // ((window)=>{
    //   window.a = 'world';
    //   console.log(window.a)
    // })(sandbox2.proxy)

  </script>
</body>
</html>